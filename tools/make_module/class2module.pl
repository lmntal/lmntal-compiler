#!/usr/bin/perl
#####################################################################
#
# 指定された Java クラスに対応する LMNtal モジュールを自動生成します
#
# (使用例)
# $ ./class2module.pl java.lang.Math
#
#####################################################################

# java の型 => Functor
%functors = (
	"int"				=> "IntegerFunctor",
	"long"				=> "IntegerFunctor",
	"float"				=> "FloatingFunctor",
	"double"			=> "FloatingFunctor",
	"boolean"			=> "SymbolFunctor",
	"java.lang.String"	=> "StringFunctor",
);

# java 変数の型 => その変数を取得するファンクタのメソッド
%getmethods = (
	"int"				=> "intValue()",
	"long"				=> "intValue()",
	"float"				=> "floatValue()",
	"double"			=> "floatValue()",
	"boolean"			=> 'getName().equals("true")?true:false',
	"java.lang.String"	=> "stringValue()",
);

# java の型 => ガード制約
%guards = (
	"int"				=> "int",
	"long"				=> "int",
	"float"				=> "float",
	"double"			=> "float",
	"java.lang.String"	=> "string",
);

#モジュールを生成するディレクトリ
$dir=".";

#####################################################################
# オプション解析
#####################################################################
use Getopt::Std;
my $opt = {}; 
getopts('d:h',$opt);
if ($opt->{'d'}) {
	$dir=$opt->{'d'};
}
#ディレクトリが存在するかどうかチェック
if (!-d $dir) {
	die "$0: Directory '$dir' is not found.\n";
}
#クラスが指定されないか、-hオプションのときは使い方を表示する
if ($opt->{'h'} || $#ARGV == -1) {
	print STDERR "Usage: $0 [options] <classes>\n";
	print STDERR "\n";
	print STDERR "\t-d <dir>\tSet output directory\n";
	exit(0);
}

#####################################################################
# メイン
#####################################################################
for ($i = 0; $i <= $#ARGV; $i++) {
	$class = $ARGV[$i];
	open(FILE, "javap -public $class |");
	
	$_=<FILE>; # Compiled from "*.java" の行は捨てる
	if (<FILE> =~ /(abstract )?(class|interface) ([\w.]+)\.(\w+)/) { #完全クラス名を取得するために必要？
		$abstract = $1; # 抽象クラスの場合 undef 以外の値が入る
		$class = $4;
		$absolute_class = $module = "$3.$4";
		$module =~ tr/./_/;
		printf STDERR "%-73s[%3d%%]\n", "$dir/$module.lmn", 100*($i+1)/($#ARGV+1);
		open(STDOUT, ">$dir/$module.lmn"); #標準出力を切り替える
		print "//-----------------------------------------------------\n";
		print "// The following code was generated by class2module.pl \n";
		print "// " . localtime(time) . "\n";
		print "//-----------------------------------------------------\n";
		print "{module($module).\n";
		if ($2 eq "interface") {
			dump_interface_module();
		} elsif ($2 eq "class") {
			$uses = "," . dump_superclass($absolute_class);
			chop($uses);
			dump_class_module();
		}
	}
	close(FILE);
	print "}.\n";
	close(STDOUT);
}

# クラスに対応するモジュールを出力する
sub dump_class_module {
	while (<FILE>) {
		if (/compareTo\(java\.lang\.Object\)/) {
			# Comparable インタフェースのメソッドは無視
		} elsif (/char|byte|short|float/) {
			#とりあえず無視
		} elsif (/public [\w.\$]+\(([\w., ]*)\)/ && $abstract eq "") { # 抽象クラスはコンストラクタなし
			my @args = split_args($1);
			if ($1 =~ /boolean/) {
				for (my $i = 0; $i <= $#args; $i++) {
					if ($args[$i] eq "boolean") {
						my @args2 = @args;
						$args2[$i] = "true";
						dump_static_method($absolute_class, "new $absolute_class", "$module.new", $uses, @args2);
						$args2[$i] = "false";
						dump_static_method($absolute_class, "new $absolute_class", "$module.new", $uses, @args2);
					}
				}
			} else {
				dump_static_method($absolute_class, "new $absolute_class", "$module.new", $uses, @args);
			}
		} elsif (/public static (?:final )?(?:synchronized )?(\S+) (\S+)\((.*)\)/) { #staticメソッド
			# 戻り値がlongのときは除外
			if (!($3 =~ /\[\]/) && $1 ne "long") { #TODO Javaの配列をLMNtalのリストで処理
				my @args = split_args($3);
				$type = trim_class($1);
				$m = $2;
				if ($3 =~ /boolean/) {
					for (my $i = 0; $i <= $#args; $i++) {
						if ($args[$i] eq "boolean") {
							my @args2 = @args;
							$args2[$i] = "true";
							dump_static_method($type, "$absolute_class.$m", "$module.".to_lmntal_method($m), "", @args2);
							$args2[$i] = "false";
							dump_static_method($type, "$absolute_class.$m", "$module.".to_lmntal_method($m), "", @args2);
						}
					}
				} else {
					dump_static_method(trim_class($1), "$absolute_class.$2", "$module.".to_lmntal_method($2), "", @args);
				}
			}
		} elsif (/public (?:abstract )?(?:final )?(?:synchronized )?(\S+) (\S+)\((.*)\)/) { #通常のメソッド
			# 戻り値がlongのときは除外
			if (!($3 =~ /\[\]/) && $1 ne "long") { #TODO Javaの配列をLMNtalのリストで処理
				my @args = split_args($3);
				$type = trim_class($1);
				$method = $2;
				if ($3 =~ /boolean/) {
					for (my $i = 0; $i <= $#args; $i++) {
						if ($args[$i] eq "boolean") {
							my @args2 = @args;
							$args2[$i] = "true";
							dump_method($type, $method, @args2);
							$args2[$i] = "false";
							dump_method($type, $method, @args2);
						}
					}
				} else {
					dump_method($type, $method, @args);
				}
			}
		} elsif (/public static final (\S+) (\w+)/) { #定数
			dump_final_variable($1, $2);
		}
	}
}

#インタフェースに対応するモジュールを出力する
sub dump_interface_module {
	print "[:/*inline_define*/\n";
	print "class LMNtal$class implements $absolute_class {\n";
	print "\tprivate Membrane mem;\n";
	print "\tpublic LMNtal$class(Membrane mem) {\n";
	print "\t\tthis.mem = mem;\n";
	print "\t}\n";
	
	while (<FILE>) {
		if (/public abstract ([\w.]+) (\S+)\((.*)\)/) {
			dump_interface_method($1, $2, $3);
		}
	}
	close(FILE);
	
	print "}\n";
	print ":].\n";
	print "\n";
	print "H=$module.new :- H=[:/*inline*/\n";
	print "\tAtom o = mem.newAtom(new ObjectFunctor(new LMNtal$class(mem)));\n";
	print "\tmem.relink(o, 0, me, 0);\n";
	print "\tme.remove();\n";
	print "\t:].\n";
	print "\n";
	print "H=$module.new({\$p,\@p}) :- H=[:/*inline*/\n";
	print "\tMembrane m = me.nthAtom(0).nthAtom(0).getMem();\n";
	print "\tAtom o = mem.newAtom(new ObjectFunctor(new LMNtal$class(m)));\n";
	print "\tmem.relink(o, 0, me, 1);\n";
	print "\tmem.relink(me.nthAtom(0), 0, me.nthAtom(0), 0);\n";
	print "\tme.remove();\n";
	print "\t:]({\$p,\@p}).\n";
}

#######################################################################
# class用メソッド
#######################################################################

# スーパークラスのインポート文を出力する
sub dump_superclass {
	my ($class) = @_;
	if ($class eq "java.lang.Object") {
		return "";
	}
	open(JAVAP, "javap -public $class |");
	while (<JAVAP>) {
		if (/public interface/) {
			return "";
		} elsif (/extends ([\w.]+)\.(\w+)/) {
			$class = $use = "$1.$2";
			if ($class eq "java.lang.Object") {
				return "";
			}
			$use =~ tr/./_/;
			$use .= ".use";
			$use .= ",($use:-())";
			last;
		}
	}
	close(JAVAP);

	# 再帰的に呼ぶ
	return $use . "," . dump_superclass($class);
}

# 引数を配列に展開する
sub split_args {
	my ($args) = @_;
	my @args = split(/\s*,\s*/, trim_class($args));
	return @args;
}

# クラス名を正しく整形する
sub trim_class {
	my ($class) = @_;
	$class =~ tr/$/./;
	return $class;
}

# ガードを出力する
sub dump_guards {
	@args = @_;
	my $guards = "";
	for (my $i = 0; $i <= $#args; $i++) {
		$arg = $args[$i];
		if ($arg eq "true" || $arg eq "false") {
			next;
		}
		if (exists($guards{$arg})) {
			$guards .= "$guards{$arg}(_$i),";
		} else {
			$guards .= "class(_$i,\"$arg\"),";
		}
	}
	chop($guards); #最後のカンマを除去
	return $guards;
}

# ヘッド部分を出力する
sub dump_head {
	my ($args, $method, @args) = @_;
	print "$method($args) :- ";
	my $guards = dump_guards(@args);
	if ($guards ne "") {
		print "$guards | ";
	}
}

# java のメソッド名から LMNtal 用のメソッド名を生成する
sub to_lmntal_method {
	my ($method) = @_;
	$method =~ s/^_//; # 先頭の _ を削除
	return lcfirst($method); # 先頭を小文字にして返す
}

# 戻り値がオブジェクトだった場合のインポートを出力する
sub dump_return_type_use {
	$_=$_[0];
	if (/^[\w]+\.[\w.]+$/) { #クラスだったら
		tr/./_/;
		return ",$_.use,($_.use:-())";
	}
	return "";
}

# メソッドを出力する
sub dump_method {
	my ($type, $method, @args) = @_;
	my $argc = $#args+1;

	my $ARGS = make_lmntal_args($type, @args);

	print "H=";
	dump_head($ARGS, to_lmntal_method($method), ($absolute_class,@args));
	print "H=[:/*inline*/\n";

	print "\t$absolute_class v0 = ($absolute_class)me.nthAtom(0).getFunctor().getValue();\n";
	
	dump_args(1, @args);
	
	dump_call_method($type, $method, $argc+1);

	for (my $i = 1; $i < $argc+1; $i++) {
		print "\tme.nthAtom($i).remove();\n";
	}
	print "\tme.remove();\n";
	print "\t:]($ARGS)" . dump_return_type_use($type). ".\n";
	print "\n";
}

# static メソッドを出力する
sub dump_static_method {
	($type, $method, $lmnmethod, $uses, @args) = @_;
	$argc = $#args+1;

	$ARGS = make_static_lmntal_args(@args);

	if ($type ne "void") {
		print "H=";
	}
	dump_head($ARGS, $lmnmethod, @args);
	if ($type ne "void") {
		print "H=";
	}
	print "[:/*inline*/\n";

	dump_args(0, @args);
	
	dump_call_static_method($type, $method, $argc);

	for (my $i = 0; $i < $argc; $i++) {
		print "\tme.nthAtom($i).remove();\n";
	}
	print "\tme.remove();\n";
	print "\t:](${ARGS})${uses}.\n";
	print "\n";
}

# LMNtal の引数の文字列を生成する
sub make_lmntal_args {
	my ($type, @args) = @_;
	my $args = "_0,";
	my $i;
	for ($i = 0; $i <= $#args; $i++) {
		my $arg = $args[$i];
		if ($arg eq "true" || $arg eq "false") {#booleanだったらアトム
			$args .= "$arg,";
		} else {#boolean以外はリンク
			$args .= "_" . ($i+1) . ",";
		}
	}
	if ($type ne "void") {
		$args .= "_" . ($i+1) . ",";
	}
	chop($args); #最後のカンマを除去
	return $args;
}

# LMNtal の引数の文字列を生成する
sub make_static_lmntal_args {
	my (@args) = @_;
	my $args = "";
	for (my $i = 0; $i <= $#args; $i++) {
		$arg = $args[$i];
		if ($arg eq "true" || $arg eq "false") {#booleanだったらアトム
			$args .= "$arg,";
		} else {#boolean以外はリンク
			$args .= "_$i,";
		}
	}
	chop($args); #最後のカンマを除去
	return $args;
}

# 引数を取得する処理の出力
sub dump_args {
	my ($start, @args) = @_;
	for (my $i = $start; $i <= $#args+$start; $i++) {
		my $type = $args[$i-$start];
		if ($type eq "true" || $type eq "false") {
			print "\tboolean v$i = $type;\n";
		} elsif (exists($functors{$type})) {
			$functor = $functors{$type};
			$getmethod = $getmethods{$type};
			printf "\t$type v$i = (($functor)me.nthAtom(%d).getFunctor()).$getmethod;\n", $i;
		} else {
			printf "\t$type v$i = ($type)me.nthAtom(%d).getFunctor().getValue();\n", $i;
		}
	}
}

sub dump_catch {
	my ($argc) = @_;
	
	print "\t} catch (Exception e) {\n";
	print "\t\tAtom res = mem.newAtom(new SymbolFunctor(\"nil\", 1));\n";
	print "\t\tmem.relink(res, 0, me, $argc);\n";
	print "\t\tAtom o = mem.newAtom(new ObjectFunctor(e));\n";
	print "\t\tmem.relink(o, 0, me, " . ($argc+1) . ");\n";
	print "\t}\n";
}

# メソッドを呼び出す部分の出力
sub dump_call_method {
	my ($type, $method, $argc) = @_;
	my $args = "";
	for (my $i = 0; $i < $argc-1; $i++) {
		$args .= "v" . ($i+1) . ",";
	}
	chop($args);
	
	if ($type eq "void") {
		print "\ttry {\n";
		print "\t\tv0.$method($args);\n";
		# 第1引数のオブジェクトを最終引数につなぐ
		print "\t\tmem.relink(me.nthAtom(0), 0, me, $argc);\n";
		print "\t} catch (Exception e) {\n";
		print "\t\tAtom o = mem.newAtom(new ObjectFunctor(e));\n";
		print "\t\tmem.relink(o, 0, me, $argc);\n";
		print "\t}\n";
		return;
	}
	
	if ($type =~ /[\w.]+\[\]/) {#配列
		print "\ttry {\n";
		print "\t\t$type r = v0.$method($args);\n";
		print "\t\truntime.Link l = new runtime.Link(me.nthAtom($argc), 0);\n";#返値アトムのリンクを取得する
		print "\t\tutil.Util.makeList(l, java.util.Arrays.asList(r));\n";
		# 第1引数のオブジェクトを最終引数につなぐ
		print "\t\tmem.relink(me.nthAtom(0), 0, me, " . ($argc+1) . ");\n";
		dump_catch($argc);
		return;
	}	

	print "\ttry {\n";
	print "\t\t$type r = v0.$method($args);\n";

	my $functor = get_result_functor($type);

	print "\t\tAtom res = mem.newAtom(new $functor);\n";
	print "\t\tmem.relink(res, 0, me, $argc);\n";
	# 第1引数のオブジェクトを最終引数につなぐ
	print "\t\tmem.relink(me.nthAtom(0), 0, me, " . ($argc+1) . ");\n";
	dump_catch($argc);
}

# javaの戻り値型から，対応するファンクタを取得する
sub get_result_functor {
	my ($type) = @_;
	
	# java の戻り値型 => 結果を返すアトム用の Functor
	my %result_functors = (
		"int"				=> "IntegerFunctor(r)",
		"long"				=> "IntegerFunctor((int)r)",
		"float"				=> "FloatingFunctor(r)",
		"double"			=> "FloatingFunctor(r)",
		"boolean"			=> "SymbolFunctor(r?\"true\":\"false\", 1)",
		"java.lang.String"	=> "StringFunctor(r)",
	);

	if (exists($result_functors{$type})) {
		return $result_functors{$type};
	} else {
		return "ObjectFunctor(r)";
	}
}

sub dump_static_catch {
	my ($argc) = @_;
	
	print "\t} catch (Exception e) {\n";
	print "\t\tAtom res = mem.newAtom(new ObjectFunctor(e));\n";
	print "\t\tmem.relink(res, 0, me, " . $argc . ");\n";
	print "\t}\n";
}

# static メソッドを呼び出す部分の出力
sub dump_call_static_method {
	my ($type, $method, $argc) = @_;
	my $args = "";
	for (my $i = 0; $i < $argc; $i++) {
		$args .= "v$i,";
	}
	chop($args);
	
	print "\ttry {\n";
	
	if ($type eq "void") {
		print "\t\t$method($args);\n";
		print "\t} catch (Exception e) {\n";
		print "\t\tSystem.err.println(e);\n";
		print "\t}\n";
		return;
	}
	
	print "\t\t$type r = $method($args);\n";
	
	if ($type =~ /[\w.]+\[\]/) {
		print "\t\truntime.Link l = new runtime.Link(me.nthAtom($argc), 0);\n";#返値アトムのリンクを取得する
		print "\t\tutil.Util.makeList(l, java.util.Arrays.asList(r));\n";
		dump_static_catch($argc);
		return;
	}

	my $functor = get_result_functor($type);

	print "\t\tAtom res = mem.newAtom(new $functor);\n";
	print "\t\tmem.relink(res, 0, me, $argc);\n";
	dump_static_catch($argc);
}

# final 定数の出力
sub dump_final_variable {
	my ($type, $name) = @_;
	
	print "H=$module." . lc($name) . " :- H=[:/*inline*/\n";
	print "\t" . trim_class($type) . " r = $absolute_class.$name;\n";
	my $functor = get_result_functor($type);
	print "\tAtom res = mem.newAtom(new $functor);\n";
	print "\tmem.relink(res, 0, me, 0);\n";
	print "\tme.remove();\n";
	print "\t:]" . dump_return_type_use($type). ".\n";
	print "\n";
}

#######################################################################
# interface用メソッド
#######################################################################

# react 部を出力する
sub dump_react {
	print "\t\tmem.lock();\n";
	print "\t\tboolean updated = true;\n";
	print "\t\twhile (updated) {\n";
	print "\t\t\tupdated = false;\n";
	print "\t\t\tfor (Iterator iter = mem.rulesetIterator(); iter.hasNext();) {\n";
	print "\t\t\t\tRuleset ruleset = (Ruleset)iter.next();\n";
	print "\t\t\t\twhile (ruleset.react(mem)) updated = true;\n";
	print "\t\t\t}\n";
	print "\t\t}\n";
	print "\t\tmem.unlock();\n";
}

# 引数アトムを生成する部分の出力
sub dump_argatom {
	my ($type, $i) = @_;
	
	if ($type eq "boolean") {
		$functor = "SymbolFunctor(v$i?\"true\":\"false\", 1)";
	} elsif (exists($functors{$type})) {
		$functor = "$functors{$type}(v$i)";
	} else {
		$functor = "ObjectFunctor(v$i)";
	}
	print "\t\tAtom a$i = mem.newAtom(new $functor);\n";
	print "\t\tmem.newLink(a, $i, a$i, 0);\n";	
}

# javaの引数を出力する
sub dump_java_args {
	my (@args) = @_;
	my $args;
	for (my $i = 0; $i <= $#args; $i++) {
		$args .= "$args[$i] v$i,";
	}
	chop($args);
	return $args;
}

# インタフェースが持つメソッドを出力する
sub dump_interface_method {
	my ($type, $method, $args) = @_;
	my @args = split(/\s*,\s*/, $args);
	my $argc = $#args+1;
	
	print "\tpublic $type $method(" . dump_java_args(@args) . ") {\n";
	
	$arity = ($type eq "void" ? $argc : $argc+1);
	print "\t\tAtom a = mem.newAtom(new SymbolFunctor(\"$method\", $arity));\n";

	for (my $i = 0; $i < $argc; $i++) {
		dump_argatom($args[$i], $i);
	}
	
	if ($type ne "void") {
		print "\t\tAtom res = mem.newAtom(new SymbolFunctor(\"res\", 1));\n";
		print "\t\tmem.newLink(a, $argc, res, 0);\n";	
	}
	
	dump_react();
	
	if ($type eq "void") {
		print "\t}\n";
		return;
	}
	
	print "\n";
	if (exists($functors{$type})) {
		print "\t\treturn (($functors{$type})res.nthAtom(0).getFunctor()).$getmethods{$type};\n";
	} else {
		print "\t\treturn ($type)res.nthAtom(0).getFunctor().getValue();\n";
	}
	
	print "\t}\n";
}
